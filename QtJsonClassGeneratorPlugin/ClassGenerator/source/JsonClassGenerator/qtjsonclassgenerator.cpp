/*****************************************************
 * project: Qt Json Class Generator
 * author: hezouzao
 * usage :
 * Step I.
 * supported types ( by now ):
 * QBitArray                    -> bit array
 * bool                         -> bool
 * QByteArray                   -> byte array
 * QChar/char                   -> char
 * QDate                        -> date
 * QDateTime                    -> date time
 * double                       -> double
 * QEasingCurve                 -> easing curve
 * float                        -> float
 * int/qint32                   -> int
 * QLine                        -> line
 * QLineF                       -> line float
 * QList<T>                     -> T, true (true means it's an array type)
 * QLocale                      -> locale
 * qlonglong/qint64/long long   -> long long
 * QModelIndex                  -> model index
 * QPersistentModelIndex        -> persistent model index
 * QPoint                       -> point
 * QPointF                      -> point float
 * qreal                        -> real
 * QRect                        -> rect
 * QRectF                       -> rect float
 * QRegExp                      -> regexp (QT_VERSION < Qt5.0)
 * QRegularExpression           -> regular expression (QT_VERSION >= Qt5.0)
 * QSize                        -> size
 * QSizeF                       -> size float
 * QString                      -> string
 * QTime                        -> time
 * uint                         -> unsigned int
 * qulonglong                   -> unsigned long long
 * QUrl                         -> url
 * QUuid                        -> unsigned unique id
 * input your script file like : family.txt
 * ###################### file: family.txt ######################
 * chinese family               # -> class ChineseFamily {};
 * member, string, true         # -> QList<QString> m_member;
 * single parent, bool, false   # -> bool m_single_parent;
 * address, string, false       # -> QString m_address;
 * ###################### file: family.txt ######################
 * and we will get hpp and cpp files: family.hpp and family.cpp,
 * you can find these two generated files from our project /demo
 * folder, and it's so easy to write a script like this, isn't?
 * and make it advancer, look at this file: person.txt
 * ###################### file: person.txt ######################
 * require family.txt           # -> include header files
 * person                       # -> class Person {};
 * name, string, false          # -> QString m_name;
 * age, int, false              # -> int m_age;
 * children, string, true       # -> QList<QString> m_children;
 * cards, int, true             # -> QList<int> m_cards;
 * family, chinese family, false# -> ChineseFamily m_family;
 * ###################### file: person.txt ######################
 * and we will get: person.hpp and person.cpp files which are
 * available in /demo folder.
 * Pay attention to "require" line, it will check if the classes
 * are generated, if not, it will generate the classes required
 * by header declaration, and then move on to compile this file.
 * and the types to describe the fields of class should either
 * be found in Qt Supported Types listed above, or the customized
 * classes generated by this system, and it cannot be the one that
 * is in the definition process, which means you cannot add a
 * field of type [person] within class definition of [person], it
 * will cause infinitive loop error.
 * [*] Plus, no spaces and single or double quotes are allowed in path
 * of the script file and the "require" header sentences.
 * [*] Plus, no more than 1023 chars are allowed to stand within a line!
 * [*] Plus, only one class can be defined in a class description file!
 * Step II.
 * when you got these generated classes, you can add your own
 * properties and methods, and they won't affect the JSON system,
 * but keep in mind that, you are always free to use these classes
 * to serialize and deserialize themselves with these API:
 * auto object = new [Generated Class]([parent]);
 * QByteArray json = object.serialize();
 * object.deserialze([instance of QByteArray]);
 */

#include "qtjsonclassgenerator.h"
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <experimental/filesystem>
#include <list>
#include <map>
#include <QMap>
#include "../Models/classitem.h"
#include <QMessageBox>
#include "../Settings/settings.h"
#include "QTemporaryFile"

#include <QtGlobal>
#include "QFileInfo"
#include "QDir"

#define _CHAR_COUNT_IN_LINE_    1024
#define _KEYWORD_REQUIRE_       "require"

const std::string get = "get";
const std::string set = "set";

const std::string publicConstructorsDestructors =
        "/*******************************************************************************\n" \
        "*                       public constructors/destructors                        *\n" \
        "*******************************************************************************/\n";

const std::string publicOperators =
        "/*******************************************************************************\n" \
        "*                               public operators                               *\n" \
        "*******************************************************************************/\n";

const std::string publicAccessorMutators =
        "/*******************************************************************************\n" \
        "*                           public accessor/mutators                           *\n" \
        "*******************************************************************************/\n";

const std::string privateQVarAccessorMutators =
        "/*******************************************************************************\n" \
        "*                           private QVar accessor/mutators                           *\n"\
        "*******************************************************************************/\n";

const std::string publicModifiers =
        "/*******************************************************************************\n" \
        "*                               public modifiers                               *\n" \
        "*******************************************************************************/\n";

const std::string publicSerializerDeserializer =
        "/*******************************************************************************\n" \
        "*                        public serializer/deserializer                        *\n" \
        "*******************************************************************************/\n";

const std::string privateMembers =
        "/*******************************************************************************\n" \
        "*                               private members                                *\n" \
        "*******************************************************************************/\n";

QMap<QString, QString> QtJsonClassGenerator::supported_types =
{
    {"bit array",              "QBitArray"              },
    {"bool",                   "bool"                   },
    {"byte array",             "QByteArray"             },
    {"char",                   "QChar"                  },
    {"date",                   "QDate"                  },
    {"date time",              "QDateTime"              },
    {"double",                 "double"                 },
    {"easing curve",           "QEasingCurve"           },
    {"float",                  "float"                  },
    {"int",                    "int"                    },
    {"line",                   "QLine"                  },
    {"line float",             "QLineF"                 },
    {"locale",                 "QLocale"                },
    {"long long",              "long"                   },
    {"model index",            "QModelIndex"            },
    {"persistent model index", "QPersistentModelIndex"  },
    {"point",                  "QPoint"                 },
    {"point float",            "QPointF"                },
    {"real",                   "qreal"                  },
    {"rect",                   "QRect"                  },
    {"rect float",             "QRectF"                 },
    {"regexp",                 "QRegExp"                },
    {"regular expression",     "QRegularExpression"     },
    {"size",                   "QSize"                  },
    {"size float",             "QSizeF"                 },
    {"string",                 "QString"                },
    {"time",                   "QTime"                  },
    {"unsigned int",           "uint"                   },
    {"unsigned long long",     "qulonglong"             },
    {"url",                    "QUrl"                   },
    {"unsigned unique id",     "QUuid"                  }
};

//// a global resource
//std::map<std::string, std::string> QtJsonClassGenerator::_supported_types =
//{
//    std::pair<std::string, std::string>("bit array",              "QBitArray"),
//    std::pair<std::string, std::string>("bool",                   "bool"),
//    std::pair<std::string, std::string>("byte array",             "QByteArray"),
//    std::pair<std::string, std::string>("char",                   "QChar"),
//    std::pair<std::string, std::string>("date",                   "QDate"),
//    std::pair<std::string, std::string>("date time",              "QDateTime"),
//    std::pair<std::string, std::string>("double",                 "double"),
//    std::pair<std::string, std::string>("easing curve",           "QEasingCurve"),
//    std::pair<std::string, std::string>("float",                  "float"),
//    std::pair<std::string, std::string>("int",                    "int"),
//    std::pair<std::string, std::string>("line",                   "QLine"),
//    std::pair<std::string, std::string>("line float",             "QLineF"),
//    std::pair<std::string, std::string>("locale",                 "QLocale"),
//    std::pair<std::string, std::string>("long long",              "long"),
//    std::pair<std::string, std::string>("model index",            "QModelIndex"),
//    std::pair<std::string, std::string>("persistent model index", "QPersistentModelIndex"),
//    std::pair<std::string, std::string>("point",                  "QPoint"),
//    std::pair<std::string, std::string>("point float",            "QPointF"),
//    std::pair<std::string, std::string>("real",                   "qreal"),
//    std::pair<std::string, std::string>("rect",                   "QRect"),
//    std::pair<std::string, std::string>("rect float",             "QRectF"),
//    std::pair<std::string, std::string>("regexp",                 "QRegExp"),
//    std::pair<std::string, std::string>("regular expression",     "QRegularExpression"),
//    std::pair<std::string, std::string>("size",                   "QSize"),
//    std::pair<std::string, std::string>("size float",             "QSizeF"),
//    std::pair<std::string, std::string>("string",                 "QString"),
//    std::pair<std::string, std::string>("time",                   "QTime"),
//    std::pair<std::string, std::string>("unsigned int",           "uint"),
//    std::pair<std::string, std::string>("unsigned long long",     "qulonglong"),
//    std::pair<std::string, std::string>("url",                    "QUrl"),
//    std::pair<std::string, std::string>("unsigned unique id",     "QUuid")
//};

std::map<std::string, std::string> _convertor_map =
{
    std::pair<std::string, std::string>("QBitArray",             "toBitArray"),
    std::pair<std::string, std::string>("bool",                  "toBool"),
    std::pair<std::string, std::string>("QByteArray",            "toByteArray"),
    std::pair<std::string, std::string>("QChar",                 "toChar"),
    std::pair<std::string, std::string>("QDate",                 "toDate"),
    std::pair<std::string, std::string>("QDateTime",             "toDateTime"),
    std::pair<std::string, std::string>("double",                "toDouble"),
    std::pair<std::string, std::string>("QEasingCurve",          "toEasyCurve"),
    std::pair<std::string, std::string>("float",                 "toFloat"),
    std::pair<std::string, std::string>("int",                   "toInt"),
    std::pair<std::string, std::string>("QLine",                 "toLine"),
    std::pair<std::string, std::string>("QLineF",                "toLineF"),
    std::pair<std::string, std::string>("QLocale",               "toLocale"),
    std::pair<std::string, std::string>("long",                  "toLongLong"),
    std::pair<std::string, std::string>("QModelIndex",           "toModeIndex"),
    std::pair<std::string, std::string>("QPersistentModelIndex", "toPersistentModelIndex"),
    std::pair<std::string, std::string>("QPoint",                "toPoint"),
    std::pair<std::string, std::string>("QPointF",               "toPointF"),
    std::pair<std::string, std::string>("qreal",                 "toReal"),
    std::pair<std::string, std::string>("QRect",                 "toRect"),
    std::pair<std::string, std::string>("QRectF",                "toRectF"),
    std::pair<std::string, std::string>("QRegExp",               "toRegExp"),
    std::pair<std::string, std::string>("QRegularExpression",    "toRegularExpression"),
    std::pair<std::string, std::string>("QSize",                 "toSize"),
    std::pair<std::string, std::string>("QSizeF",                "toSizeF"),
    std::pair<std::string, std::string>("QString",               "toString"),
    std::pair<std::string, std::string>("QTime",                 "toTime"),
    std::pair<std::string, std::string>("uint",                  "toUInt"),
    std::pair<std::string, std::string>("qulonglong",            "toULongLong"),
    std::pair<std::string, std::string>("QUrl",                  "toUrl"),
    std::pair<std::string, std::string>("QUuid",                 "toUuid")
};

QList<QString> needed_types =
{
    QString("QObject"),
    QString("QString"),
    QString("QList"),
    QString("QByteArray"),
    QString("QVariant"),
    QString("QVariantMap"),
    QString("QVariantList")
};

std::list<std::string> classes;

bool        compile(const char *script, std::string &generated_class);
std::string trim(const std::string &str);
bool        is_name_valide(bool is_head, const std::string &str);

std::list<std::string> split(const std::string &str, char delimiter);
bool                   make_class_name(std::string &name, std::list<std::string> &words, bool make_first_upper);
std::string            make_file_head_macro(const std::string &str);
bool                   do_class_exists(const std::list<std::string> &classes, const std::string &class_name);
bool                   do_generated_class_exists(QVector<ClassItem*>* classItems, int thisClsItemIndex, const QString &class_name);
bool                   make_field_name(std::string &name, const std::string &field_name, bool make_first_upper);
//void                   signalCreateTabClass(const QString& filePathe);

// the core compile function
bool QtJsonClassGenerator::compile(QVector<ClassItem*>* &classItems, int clsItemIndex) {
    std::stringstream                               hppfile;
    std::stringstream                               cppfile;
    std::pair<std::string, std::string>             class_name;
    std::list<std::string>                          required_classes;
    std::list<std::pair<std::string, std::string>>  field_names;
    std::list<std::string>                          field_types;
    std::list<bool>                                 field_is_list;
    std::list<bool>                                 type_is_builtin;
    bool                                            is_class_contained = false;

    ClassItem *clsItem = classItems->at(clsItemIndex);
    //fill class name

    QString clsName = clsItem->getClassName();
    class_name.first = clsName.toStdString();
    clsName[0] = clsName.at(0).toLower();
    class_name.second = clsName.toStdString();

    //fill required classes
    for (int i = 0 ; i < clsItem->requiredClasses_count() ; i++)
    {
        RequiredClass *rCls = clsItem->requiredClasses_get(i);
        required_classes.push_back(rCls->getClassnameForGen().toStdString());
    }

    //fill class properties
    for (int i = 0 ; i < clsItem->classProperties_count() ; i++)
    {
        ClassProperty *clsProp = clsItem->classProperties_get(i);

        std::list<std::string> words;
        words.push_back(clsProp->getName().toStdString());
        words.push_back(clsProp->getType().toStdString());
        words.push_back(clsProp->getIsCollection()  ? "true" : "false");

        //        // this is a field declaration
        bool _is_type_builtin = false;

        std::string _field_name;
        std::string _method_name;
        if (!make_field_name(_field_name, trim(words.front()), false)
                || !make_field_name(_method_name, trim(words.front()), true)) {
            QMessageBox* msg = new QMessageBox();
            msg->setWindowTitle("Warning !");
            msg->setText("Bad format for field name: " + QString::fromStdString(_field_name) + " !");
            msg->show();

            return(false);
        }
        words.pop_front();
        std::string _type = trim(words.front());
        // check if it is a built-in type
        QMap<QString, QString>::const_iterator t_itr = QtJsonClassGenerator::supported_types.find(QString::fromStdString(_type));
        if (t_itr != QtJsonClassGenerator::supported_types.end()) {
            _is_type_builtin = true;
            _type            = t_itr.value().toStdString();
        } else {
            // check if this is a registered class
            QString typeName = QString::fromStdString(_type);
            _is_type_builtin = false;
            std::list<std::string> t_list = split(_type, ' ');
            if (!make_class_name(_type, t_list, true)) {
                return(false);
            }

            if (!do_generated_class_exists(classItems, clsItemIndex, QString::fromStdString(_type))) {
                QMessageBox* msg = new QMessageBox();
                msg->setWindowTitle("Warning !");
                msg->setText("Class " + clsName + " not generated! Not found required class: " + typeName);
                msg->show();
                return(false);
            }
        }
        words.pop_front();
        std::string t_list = trim(words.front());
        bool        _list;
        words.pop_front();
        if (t_list == std::string("true")) {
            _list = true;
        } else if (t_list == std::string("false")) {
            _list = false;
        } else {
            QMessageBox* msg = new QMessageBox();
            msg->setWindowTitle("Warning !");
            msg->setText(QString("Bad bool value for describing if a field is a list type: ") + (_list ? "true" : "false"));
            msg->show();

            return(false);
        }
        // add to field list
        field_names.push_back(std::pair<std::string, std::string>(_field_name, _method_name));
        field_types.push_back(_type);
        field_is_list.push_back(_list);
        type_is_builtin.push_back(_is_type_builtin);
    }

    // check if this description file contains a class
    is_class_contained = true;
    if (!is_class_contained) {
        return(true);
    }
    // do the real job to generate files of classes
     std::cout << "[OK] begin generate class [ " << class_name.first << " ]" << std::endl;
    // create class related files : hpp and cpp files
    std::string hppname = class_name.first; //name and path to file
    std::string cppname = class_name.first;
    hppname.append(".h");

    // hpp header
    hppfile << "#ifndef " << make_file_head_macro(class_name.first) << std::endl;
    hppfile << "#define " << make_file_head_macro(class_name.first) << std::endl;
    hppfile << std::endl;




    // add external headers for field type requirement
    std::list<std::string>::const_iterator                          itype = field_types.begin();
    //    std::list<std::string>::const_iterator                          intype = needed_types.begin();
    std::list<std::pair<std::string, std::string> >::const_iterator iname;
    std::list<bool>::const_iterator                                 ilist;
    std::list<bool>::const_iterator                                 ibuiltin = type_is_builtin.begin();

    //    hppfile << "#include <QObject>" << std::endl;
    //    hppfile << "#include <QString>" << std::endl;
    //    hppfile << "#include <QList>" << std::endl;
    //    hppfile << "#include <QVariant>" << std::endl;
    //    hppfile << "#include <QByteArray>" << std::endl;
    //    hppfile << "#include <QVariantList>" << std::endl;
    //    hppfile << "#include <QVariantMap>" << std::endl;

    for (int i = 0 ; i < needed_types.size() ; i++) {
        hppfile << "#include <" << needed_types.at(i).toStdString() << ">" << std::endl;
    }

    for ( ; itype != field_types.end(); itype++) {
        if ((*itype)[0] == 'Q' && (*ibuiltin)) {

            int indF = needed_types.indexOf(QString::fromStdString(*itype));
            if (indF == -1)
                hppfile << "#include <" << *itype << ">" << std::endl;
        }
    }
    hppfile << std::endl;
    // cpp header
    cppfile << "#include \"" << hppname << "\"" << std::endl;
    cppfile << "#include \"qjson-qt5/qobjecthelper.h\"" << std::endl;
    cppfile << "#include \"qjson-qt5/serializer.h\"" << std::endl;
    cppfile << "#include \"qjson-qt5/parser.h\"" << std::endl;

    // add begin namespaces to .cpp
    if (clsItem->namespaces_count() > 0)
    {
        cppfile << std::endl;
    }

    for (int i = 0; i < clsItem->namespaces_count(); i++)
    {
        QString nsStr = clsItem->namespaces_get(i);
        cppfile << "namespace " << nsStr.toStdString() << " {" << std::endl;
    }

    cppfile << std::endl;

    cppfile << publicConstructorsDestructors;
    cppfile << class_name.first << "::" << class_name.first << "(QObject* parent) : QObject(parent){}" << std::endl;
    cppfile << class_name.first << "::~" << class_name.first << "(){}" << std::endl;
    cppfile << std::endl;

    // add generated classes
    std::list<std::string>::const_iterator itr = required_classes.begin();
    for ( ; itr != required_classes.end(); itr++) {
        hppfile << "#include \"" << *itr << ".h\"" << std::endl;
    }
    if (clsItem->requiredClasses_count() > 0)
    {
        hppfile << std::endl;
    }

    // add begin namespaces to .h
    for (int i = 0; i < clsItem->namespaces_count(); i++)
    {
        QString nsStr = clsItem->namespaces_get(i);
        hppfile << "namespace " << nsStr.toStdString() << " {" << std::endl;
    }
    if (clsItem->namespaces_count() > 0)
    {
        hppfile << std::endl;
    }

    hppfile << "class " << class_name.first << " : public QObject" << std::endl;
    hppfile << "{" << std::endl;
    hppfile << "\tQ_OBJECT" << std::endl;

    // add constructors to cpp file
    itype    = field_types.begin();
    iname    = field_names.begin();
    ilist    = field_is_list.begin();
    ibuiltin = type_is_builtin.begin();

    cppfile << class_name.first << "::" << class_name.first << "(const " << class_name.first << " &" << class_name.second << ") : QObject(" << class_name.second << ".parent())" << std::endl;
    cppfile << "{" << std::endl;
    for ( ; iname != field_names.end(); iname++) {
        cppfile << "\t" << set << iname->second << "(" << class_name.second << "." << get << iname->second << "());" << std::endl;
    }
    if (!Settings::useLightGenerated)
    {
        cppfile << "\tm_ok = " << class_name.second << ".ok();" << std::endl;
    }
//     m_ok = family.ok();
    //    for ( ; iname != field_names.end(); ++itype, ++iname, ++ilist, ++ibuiltin) {
    //        if (*ilist) {
    //            cppfile << "\t" << set << iname->second << "QVar" << "(" << class_name.second << "." << get << iname->second << "QVar" << "());" << std::endl;
    //        }
    //        else
    //        {
    //            if (*ibuiltin) {
    //                // norm getters, setters
    //                cppfile << "\t" << set << iname->second << "(" << class_name.second << "." << get << iname->second << "());" << std::endl;
    //            }
    //            else
    //            {
    //                cppfile << "\t" << set << iname->second << "QVar" << "(" << class_name.second << "." << get << iname->second << "QVar" << "());" << std::endl;
    //            }
    //        }
    //    }

    cppfile << "}" << std::endl;
    cppfile << std::endl;
    cppfile << publicOperators;
    cppfile << class_name.first << " &" << class_name.first << "::operator=(const " << class_name.first << " &" << class_name.second << ")" << std::endl;
    cppfile << "{" << std::endl;

    for (iname = field_names.begin(); iname != field_names.end(); iname++) {
        cppfile << "\t" << set << iname->second << "(" << class_name.second << "." << get << iname->second << "());" << std::endl;
    }
    if (!Settings::useLightGenerated)
    {
        cppfile << "\tm_ok = " << class_name.second << ".ok();" << std::endl;
    }

    //    itype    = field_types.begin();
    //    iname    = field_names.begin();
    //    ilist    = field_is_list.begin();
    //    ibuiltin = type_is_builtin.begin();

    //    for ( ; iname != field_names.end(); ++itype, ++iname, ++ilist, ++ibuiltin) {
    //        if (*ilist) {
    //            cppfile << "\t" << set << iname->second << "QVar" << "(" << class_name.second << "." << get << iname->second << "QVar" << "());" << std::endl;
    //        }
    //        else
    //        {
    //            if (*ibuiltin) {
    //                // norm getters, setters
    //                cppfile << "\t" << set << iname->second << "(" << class_name.second << "." << get << iname->second << "());" << std::endl;
    //            }
    //            else
    //            {
    //                cppfile << "\t" << set << iname->second << "QVar" << "(" << class_name.second << "." << get << iname->second << "QVar" << "());" << std::endl;
    //            }
    //        }
    //    }

    cppfile << "\treturn *this;" << std::endl;
    cppfile << "}" << std::endl;
    cppfile << std::endl;

    if (!Settings::useLightGenerated)
    {
        for (iname = field_names.begin(); itype != field_types.end(); ++itype, ++iname, ++ilist, ++ibuiltin) {
            if (*ilist) {
                hppfile << "\tQ_PROPERTY(QVariantList " << iname->first << " READ " << get << iname->second << "QVar" << " WRITE " << set << iname->second << "QVar" << ")" << std::endl;
            } else {
                if (*ibuiltin) {
                    hppfile << "\tQ_PROPERTY(" << *itype << " " << iname->first << " READ " << get << iname->second << " WRITE " << set << iname->second << ")" << std::endl;
                } else {
                    hppfile << "\tQ_PROPERTY(QVariantMap " << iname->first << " READ " << get << iname->second << "QVar" << " WRITE " << set << iname->second << "QVar" << ")" << std::endl;
                }
            }
        }
    }

    hppfile << std::endl;
    hppfile << "public:" << std::endl;
    hppfile << std::endl;

    hppfile << publicConstructorsDestructors;
    hppfile << "\t" << class_name.first << "(QObject* parent=0);" << std::endl;
    hppfile << "\tvirtual ~" << class_name.first << "();" << std::endl;
    hppfile << "\t" << class_name.first << "(const " << class_name.first << " &" << class_name.second << ");" << std::endl;
    hppfile << std::endl << publicOperators;
    hppfile << "\t" << class_name.first << " &operator=(const " << class_name.first << " &" << class_name.second << ");" << std::endl;
    hppfile << std::endl;

    // fill public accessor/mutators
    itype    = field_types.begin();
    iname    = field_names.begin();
    ilist    = field_is_list.begin();
    ibuiltin = type_is_builtin.begin();

    cppfile << publicAccessorMutators;
    hppfile << publicAccessorMutators;
    for ( ; itype != field_types.end(); ++itype, ++iname, ++ilist, ++ibuiltin) {
        if (*ilist)
        {
//            if (*ibuiltin) {
//                // declaration
//                hppfile << "\t" << *itype << " " << get << iname->second << "() const;" << std::endl;
//                hppfile << "\tvoid " << set << iname->second << "(const " << *itype << " &" << iname->first << ");" << std::endl;
//                hppfile << std::endl;
//                // implementation
//                // getter
//                cppfile << *itype << " " << class_name.first << "::" << get << iname->second << "() const" << std::endl;
//                cppfile << "{" << std::endl;
//                cppfile << "\treturn m_" << iname->first << ";" << std::endl;
//                cppfile << "}" << std::endl;
//                cppfile << std::endl;
//                // setter
//                cppfile << "void " << class_name.first << "::" << set << iname->second << "(const " << *itype << " &" << iname->first << ")" << std::endl;
//                cppfile << "{" << std::endl;
//                cppfile << "\tthis->m_" << iname->first << " = " << iname->first << ";" << std::endl;
//                cppfile << "}" << std::endl;
//                cppfile << std::endl;
//            }
//            else
            {
                // declaration
                hppfile << "\t" << "QList<" << *itype << "> " << get << iname->second << "() const;" << std::endl;
                hppfile << "\tvoid " << set << iname->second << "(const " << "QList<" <<*itype << "> &" << iname->first << ");" << std::endl;
                hppfile << std::endl;
                // implementation
                // getter
                cppfile << "QList<" << *itype << "> " << class_name.first << "::" << get << iname->second << "() const" << std::endl;
                cppfile << "{" << std::endl;
                cppfile << "\treturn m_" << iname->first << ";" << std::endl;
                cppfile << "}" << std::endl;
                cppfile << std::endl;
                // setter
                cppfile << "void " << class_name.first << "::" << set << iname->second << "(const " << "QList<" << *itype << "> &" << iname->first << ")" << std::endl;
                cppfile << "{" << std::endl;
                cppfile << "\tthis->m_" << iname->first << " = " << iname->first << ";" << std::endl;
                cppfile << "}" << std::endl;
                cppfile << std::endl;
            }
        }
        else
        {
            // declaration
            hppfile << "\t" << *itype << " " << get << iname->second << "() const;" << std::endl;
            hppfile << "\tvoid " << set << iname->second << "(const " << *itype << " &" << iname->first << ");" << std::endl;
            hppfile << std::endl;
            // implementation
            // getter
            cppfile << *itype << " " << class_name.first << "::" << get << iname->second << "() const" << std::endl;
            cppfile << "{" << std::endl;
            cppfile << "\treturn m_" << iname->first << ";" << std::endl;
            cppfile << "}" << std::endl;
            cppfile << std::endl;
            // setter
            cppfile << "void " << class_name.first << "::" << set << iname->second << "(const " << *itype << " &" << iname->first << ")" << std::endl;
            cppfile << "{" << std::endl;
            cppfile << "\tthis->m_" << iname->first << " = " << iname->first << ";" << std::endl;
            cppfile << "}" << std::endl;
            cppfile << std::endl;
        }
        //        }
    }

    cppfile << publicModifiers;
    hppfile << publicModifiers;
    for (iname = field_names.begin(), itype = field_types.begin(), ilist = field_is_list.begin();
         iname != field_names.end();
         iname++, itype++, ilist++) {
        if (*ilist) {
            // declaration
            hppfile << "\tQList<" << *itype << "> &" << get << iname->second << "Ref();" << std::endl;
            // implementation
            cppfile << "QList<" << *itype << "> &" << class_name.first << "::" << get << iname->second << "Ref()" << std::endl;
            cppfile << "{" << std::endl;
            cppfile << "\treturn m_" << iname->first << ";" << std::endl;
            cppfile << "}" << std::endl;
            cppfile << std::endl;
        } else {
            // declaration
            hppfile << "\t" << *itype << " &" << get << iname->second << "Ref();" << std::endl;
            // implementation
            cppfile << *itype << " &" << class_name.first << "::" << get << iname->second << "Ref()" << std::endl;
            cppfile << "{" << std::endl;
            cppfile << "\treturn m_" << iname->first << ";" << std::endl;
            cppfile << "}" << std::endl;
            cppfile << std::endl;
        }
    }

    if (!Settings::useLightGenerated)
    {
        cppfile << publicSerializerDeserializer;
        hppfile << std::endl << publicSerializerDeserializer;
        hppfile << "\tQByteArray serialize();" << std::endl;
        hppfile << "\tvoid deserialize(const QByteArray &data);" << std::endl;
        hppfile << "\tbool ok() const;" << std::endl;
        // implementation
        // serializer
        cppfile << "QByteArray " << class_name.first << "::serialize()" << std::endl;
        cppfile << "{" << std::endl;
        cppfile << "\tQVariantMap map = QJson::QObjectHelper::qobject2qvariant(this);" << std::endl;
        cppfile << "\tQJson::Serializer serializer;" << std::endl;
        cppfile << "\treturn serializer.serialize(map, &m_ok);" << std::endl;
        cppfile << "}" << std::endl;
        cppfile << std::endl;
        // deserializer
        cppfile << "void " << class_name.first << "::deserialize(const QByteArray &data)" << std::endl;
        cppfile << "{" << std::endl;
        cppfile << "\tQJson::Parser parser;" << std::endl;
        cppfile << "\tQVariant var = parser.parse(data, &m_ok);" << std::endl;
        cppfile << "\tQJson::QObjectHelper::qvariant2qobject(var.toMap(), this);" << std::endl;
        cppfile << "}" << std::endl;
        cppfile << std::endl;

        // ok
        cppfile << "bool " << class_name.first << "::ok() const" << std::endl;
        cppfile << "{" << std::endl;
        cppfile << "\treturn m_ok;" << std::endl;
        cppfile << "}" << std::endl;
        cppfile << std::endl;
    }

    hppfile << std::endl;
    hppfile << "private:" << std::endl;
    hppfile << std::endl;

    // fill private QVar accessor/mutators
    itype    = field_types.begin();
    iname    = field_names.begin();
    ilist    = field_is_list.begin();
    ibuiltin = type_is_builtin.begin();

    if (!Settings::useLightGenerated)
    {
        cppfile << privateQVarAccessorMutators;
        hppfile << privateQVarAccessorMutators;
        for ( ; itype != field_types.end(); ++itype, ++iname, ++ilist, ++ibuiltin) {
            if (*ilist) {
                hppfile << "\tQVariantList " << get << iname->second << "QVar" << "() const;" << std::endl;
                hppfile << "\tvoid " << set << iname->second << "QVar" << "(const QVariantList &" << iname->first << ");" << std::endl;
                hppfile << std::endl;
                // implementation
                if (*ibuiltin) {
                    // getter
                    cppfile << "QVariantList " << class_name.first << "::" << get << iname->second << "QVar" << "() const" << std::endl;
                    cppfile << "{" << std::endl;
                    cppfile << "\tQVariantList " << iname->first << ";" << std::endl;
                    cppfile << "\tQList<" << *itype << ">::const_iterator itr=m_" << iname->first << ".begin();" << std::endl;
                    cppfile << "\tfor(; itr!=m_" << iname->first << ".end(); itr++)" << std::endl;
                    cppfile << "\t\t" << iname->first << ".push_back(*itr);" << std::endl;
                    cppfile << "\treturn " << iname->first << ";" << std::endl;
                    cppfile << "}" << std::endl;
                    cppfile << std::endl;
                    //setter
                    cppfile << "void " << class_name.first << "::" << set << iname->second << "QVar" << "(const QVariantList &" << iname->first << ")" << std::endl;
                    cppfile << "{" << std::endl;
                    cppfile << "\tQVariantList::const_iterator itr=" << iname->first << ".begin();" << std::endl;
                    cppfile << "\tm_" << iname->first << ".clear();" << std::endl;
                    cppfile << "\tfor(; itr!=" << iname->first << ".end(); itr++)" << std::endl;
                    std::map<std::string, std::string>::const_iterator iconv = _convertor_map.find(*itype);
                    if (iconv == _convertor_map.end()) {
                        std::cout << "[ERROR] no available convertor for type: " << *itype << std::endl;
                        return(false);
                    }
                    cppfile << "\t\tm_" << iname->first << ".push_back((*itr)." << iconv->second << "());" << std::endl;
                    cppfile << "}" << std::endl;
                    cppfile << std::endl;
                } else {
                    // getter
                    cppfile << "QVariantList " << class_name.first << "::" << get << iname->second << "QVar" << "() const" << std::endl;
                    cppfile << "{" << std::endl;
                    cppfile << "\tQVariantList " << iname->first << ";" << std::endl;
                    cppfile << "\tQList<" << *itype << ">::const_iterator itr=m_" << iname->first << ".begin();" << std::endl;
                    cppfile << "\tfor(; itr!=m_" << iname->first << ".end(); itr++)" << std::endl;
                    cppfile << "\t{" << std::endl;
                    cppfile << "\t\t" << *itype << " _ref = *itr;" << std::endl;
                    cppfile << "\t\t" << iname->first << ".push_back(QJson::QObjectHelper::qobject2qvariant(&_ref));" << std::endl;
                    cppfile << "\t}" << std::endl;
                    cppfile << "\treturn " << iname->first << ";" << std::endl;
                    cppfile << "}" << std::endl;
                    cppfile << std::endl;
                    // setter
                    cppfile << "void " << class_name.first << "::" << set << iname->second << "QVar" << "(QVariantList const &" << iname->first << ")" << std::endl;
                    cppfile << "{" << std::endl;
                    cppfile << "\tm_" << iname->first << ".clear();" << std::endl;
                    cppfile << "\tQVariantList::const_iterator itr=" << iname->first << ".begin();" << std::endl;
                    cppfile << "\tfor(; itr!=" << iname->first << ".end(); itr++)" << std::endl;
                    cppfile << "\t{" << std::endl;
                    cppfile << "\t\t" << *itype << " _ref;" << std::endl;
                    cppfile << "\t\tQJson::QObjectHelper::qvariant2qobject((*itr).toMap(), &_ref);" << std::endl;
                    cppfile << "\t\tm_" << iname->first << ".push_back(_ref);" << std::endl;
                    cppfile << "\t}" << std::endl;
                    cppfile << "}" << std::endl;
                    cppfile << std::endl;
                }
            }
            else
            {
                if (!*ibuiltin) {
                    // declaration
                    hppfile << "\tQVariantMap " << get << iname->second << "QVar" << "() const;" << std::endl;
                    hppfile << "\tvoid " << set << iname->second << "QVar" << "(QVariantMap const &" << iname->first << ");" << std::endl;
                    hppfile << std::endl;
                    // implementation
                    // getter
                    cppfile << "QVariantMap " << class_name.first << "::" << get << iname->second << "QVar" << "() const" << std::endl;
                    cppfile << "{" << std::endl;
                    cppfile << "\treturn QJson::QObjectHelper::qobject2qvariant(&m_" << iname->first << ");" << std::endl;
                    cppfile << "}" << std::endl;
                    cppfile << std::endl;
                    // setter
                    cppfile << "void " << class_name.first << "::" << set << iname->second << "QVar" << "(QVariantMap const &" << iname->first << ")" << std::endl;
                    cppfile << "{" << std::endl;
                    cppfile << "\tQJson::QObjectHelper::qvariant2qobject(" << iname->first << ", &m_" << iname->first << ");" << std::endl;
                    cppfile << "}" << std::endl;
                    cppfile << std::endl;
                }
            }
        }
    }

    hppfile << privateMembers;
    for (iname = field_names.begin(), itype = field_types.begin(), ilist = field_is_list.begin();
         iname != field_names.end();
         iname++, itype++, ilist++) {
        if (*ilist) {
            hppfile << "\tQList<" << *itype << "> m_" << iname->first << ";" << std::endl;
        } else {

            std::string defVal = "";
            std::string strType = *itype;

            if (strType == "int" || strType == "double" || strType == "float"
                    || strType == "uint" || strType == "qulonglong" || strType == "long")
                defVal = " = 0";
            if (strType == "bool")
                defVal = " = false";

            hppfile << "\t" << *itype << " m_" << iname->first << defVal << ";" << std::endl;
        }
    }
    if (!Settings::useLightGenerated)
    {
        hppfile << "\tbool m_ok = false;" << std::endl;
    }

    hppfile << "};" << std::endl;
    hppfile << std::endl;

    // add begin namespaces
    for (int i = 0; i < clsItem->namespaces_count(); i++)
    {
        QString nsStr = clsItem->namespaces_get(i);
        hppfile << "} // namespace " << nsStr.toStdString() << std::endl;
        cppfile << "} // namespace " << nsStr.toStdString() << std::endl;
    }

    hppfile << std::endl;
    hppfile << "#endif // " << make_file_head_macro(class_name.first) << std::endl;
    hppfile << std::endl;

    // accpet Uncrustify style
    if (Settings::useUncrustify)
    {
        QTemporaryFile tempFileH;

        if (tempFileH.open()) {
            std::string pathTempFileH = tempFileH.fileName().toStdString();

            std::ofstream tempFileHStream(pathTempFileH);
            tempFileHStream << hppfile.str();

            char tempH[512];
            sprintf(tempH, "uncrustify -c '%s' -f '%s' -o '%s'", Settings::pathConfigUncrustify.toStdString().c_str(),
                    pathTempFileH.c_str(), pathTempFileH.c_str());
            system((char *)tempH);

            QFile file(QString::fromStdString(pathTempFileH));
            if (file.open(QFile::ReadOnly | QFile::Text))
            {
                hppfile.str(file.readAll().toStdString());
            }
            file.remove();
        }

        QTemporaryFile tempFileCpp;

        if (tempFileCpp.open()) {
            std::string pathTempFileCpp = tempFileCpp.fileName().toStdString();

            std::ofstream tempFileCppStream(pathTempFileCpp);
            tempFileCppStream << cppfile.str();

            char tempCPP[512];
            sprintf(tempCPP, "uncrustify -c '%s' -f '%s' -o '%s'", Settings::pathConfigUncrustify.toStdString().c_str(),
                    pathTempFileCpp.c_str(), pathTempFileCpp.c_str());
            system((char *)tempCPP);

            QFile file(QString::fromStdString(pathTempFileCpp));
            if (file.open(QFile::ReadOnly | QFile::Text))
            {
                cppfile.str(file.readAll().toStdString());
            }
            file.remove();
        }
    }

    clsItem->setHStream(hppfile.str());
    clsItem->setCppStream(cppfile.str());

    return(true);
} // compile

std::string trim(const std::string &str) {
    int n        = str.length();
    int left_pos = 0;

    // trim spaces off in front
    for (int i = 0; i < n; ++i) {
        if (str[i] == ' ') {
            ++left_pos;
        } else {
            break;
        }
    }
    // trim spaces off at back
    int right_pos = n - 1;
    for (int i = n - 1; i >= 0; --i) {
        if (str[i] == ' ') {
            --right_pos;
        } else {
            break;
        }
    }
    return(str.substr(left_pos, right_pos - left_pos + 1));
}

bool is_name_valide(bool is_head, const std::string &str) {
    int n = str.length();

    if (!n) {
        return(false);
    }
    int pos = 0;
    if (is_head) {
        // the first alphabet
        char ch = str[pos++];
        if (ch != '_' && (ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z')) {
            return(false);
        }
    }
    for (int i = pos; i < n; ++i) {
        char ch = str[i];
        if (ch != '_' && (ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z') && (ch < '0' || ch > '9')) {
            return(false);
        }
    }

    return(true);
}

// please ensure to use the list with pop_front() to get right order
std::list<std::string> split(const std::string &str, char delimiter) {
    std::list<std::string> words;
    int                    n        = str.length();
    int                    last_id  = -1;
    int                    word_len = 0;
    for (int i = 0; i < n; i++) {
        if (str[i] == delimiter) {
            if (word_len > 0) {
                words.push_back(str.substr(last_id + 1, word_len));
            }
            last_id  = i;
            word_len = 0;
        } else {
            word_len++;
        }
    }
    if (last_id < n - 1) {
        words.push_back(str.substr(last_id + 1, word_len));
    }
    return(words);
}

// words will be emptied
bool make_class_name(std::string &name, std::list<std::string> &words, bool make_first_upper) {
    // for the first word in list
    name.clear();
    std::string word = words.front();
    words.pop_front();
    if (!is_name_valide(true, word)) {
        return(false);
    }
    // make the first letter capsulated
    if (make_first_upper) {
        if (word[0] >= 'a' && word[0] <= 'z') {
            word[0] = word[0] - ('a' - 'A');
        }
    } else {
        if (word[0] >= 'A' && word[0] <= 'Z') {
            word[0] = word[0] + ('a' - 'A');
        }
    }
    name.append(word);
    while (words.size()) {
        word = words.front();
        words.pop_front();
        if (!is_name_valide(false, word)) {
            return(false);
        }
        if (word[0] >= 'a' || word[0] <= 'z') {
            word[0] = word[0] - ('a' - 'A');
        }
        name.append(word);
    }

    return(true);
}

std::string make_file_head_macro(const std::string &str) {
    std::string macro_name = str;
    int         n          = str.size();
    for (int i = 0; i < n; i++) {
        if (str[i] >= 'a' && str[i] <= 'z') {
            macro_name[i] = str[i] - ('a' - 'A');
        }
    }
    macro_name.append("_H");
    return(macro_name);
}

bool do_class_exists(const std::list<std::string> &classes, const std::string &class_name) {
    std::list<std::string>::const_iterator i = classes.begin();
    for ( ; i != classes.end(); ++i) {
        if ((*i) == class_name) {
            return(true);
        }
    }

    return(false);
}

bool do_generated_class_exists(QVector<ClassItem*>* classItems, int thisClsItemIndex, const QString &class_name)
{
    for (int i = 0 ; i < classItems->count() ; i++)
    {
        if (classItems->at(i)->getClassName() == class_name)
        {
            return true;
        }
    }

    ClassItem *thisCLsItem = classItems->at(thisClsItemIndex);
    for (int i = 0 ; i < thisCLsItem->requiredClasses_count() ; i++)
    {
        RequiredClass *rCls = thisCLsItem->requiredClasses_get(i);
        if (rCls->getClassnameForGen() == class_name)
        {
            QFileInfo fi(thisCLsItem->getScriptFilePath());
//            QString path = fi.dir().absolutePath() + "/" + rCls->getFileName();
            QString path = rCls->getAbsoluteFilePath();
            QFile rFile(path);

            if(!rFile.exists())
                return false;

            // First: Create class item, call mainwindow createTabPageClass
            thisCLsItem->signalCreateNewTabClassByRequiredFilePath(path);

            // Second: SaveChanges, call refactor mainwindow on_pbGenerateAllClasses_clicked
            if(thisCLsItem->signalProxyGenerateClass(thisClsItemIndex + 1))
                return true;

            break;
        }
    }

    return false;
}

bool make_field_name(std::string &name, const std::string &field_name, bool make_first_upper) {
    name.clear();
    std::list<std::string> words = split(field_name, ' ');
    std::string            word  = words.front();
    words.pop_front();
    if (!is_name_valide(true, word)) {
        return(false);
    }
    // make the first letter upper o lower
    if (make_first_upper) {
        if (word[0] >= 'a' && word[0] <= 'z') {
            word[0] = word[0] - ('a' - 'A');
        }
    } else {
        if (word[0] >= 'A' && word[0] <= 'Z') {
            word[0] = word[0] + ('a' - 'A');
        }
    }
    name.append(word);
    while (words.size()) {
        word = words.front();
        words.pop_front();
        if (!is_name_valide(false, word)) {
            return(false);
        }
        if (word[0] >= 'a' || word[0] <= 'z') {
            word[0] = word[0] - ('a' - 'A');
        }
        name.append(word);
    }
    return(true);
}
